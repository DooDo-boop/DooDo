<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>DooDo v0.3.7 (Proper Undo)</title>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    html, body { 
      width:100%; height:100%; 
      overflow:hidden;
      touch-action:none;
    }
    body { 
      background: #E594BF;
      font-family: sans-serif;
      position:fixed;
    }
    #palette {
      display:flex; background:#fff; padding:8px;
      gap:12px; align-items:center;
      position:relative;
      z-index:10;
    }
    .shape-icon, .color-swatch {
      width:32px; height:32px;
      border:2px solid #ccc; border-radius:4px;
      display:flex; justify-content:center; align-items:center;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color:transparent;
    }
    .color-swatch { border-radius:50%; }
    #canvas {
      position:fixed;
      width:100vw; 
      height:calc(100vh - 52px);
      top:52px;
      left:0;
      overflow:hidden;
    }
    .canvas-shape {
      position:absolute; 
      touch-action:none;
      user-select:none;
      -webkit-user-select:none;
      transform-origin: center center;
      will-change: transform;
      transition: none;
    }
    .canvas-shape.selected {
      outline: 2px dashed black;
    }
    #undo-btn {
      position: fixed;
      bottom: 12px;
      right: 12px;
      z-index: 99;
      padding: 8px 12px;
      background: white;
      border: 2px solid #ccc;
      border-radius: 4px;
      font-family: sans-serif;
      cursor: pointer;
    }
    #undo-btn:active {
      background: #f0f0f0;
    }
  </style>
</head>
<body>
  <div id="palette">
    <div id="shape-palette">
      <div class="shape-icon" data-shape="circle">◯</div>
      <div class="shape-icon" data-shape="rect">◻︎</div>
      <div class="shape-icon" data-shape="triangle">△</div>
    </div>
    <div id="color-palette">
      <div class="color-swatch" data-color="#2E3192" style="background:#2E3192;"></div>
      <div class="color-swatch" data-color="rgba(237,28,36,0.56)" style="background:rgba(237,28,36,0.56);"></div>
      <div class="color-swatch" data-color="#FAF073" style="background:#FAF073;"></div>
    </div>
  </div>
  <div id="canvas"></div>
  <button id="undo-btn">Undo</button>

  <script>
    const shapeSVGs = {
      circle: '<svg xmlns="http://www.w3.org/2000/svg" width="80" height="80"><circle cx="40" cy="40" r="40"/></svg>',
      rect: '<svg xmlns="http://www.w3.org/2000/svg" width="80" height="80"><rect width="80" height="80"/></svg>',
      triangle: '<svg xmlns="http://www.w3.org/2000/svg" width="80" height="80"><polygon points="40,0 80,80 0,80"/></svg>'
    };

    const canvas = document.getElementById('canvas');
    let selectedColor = '#2E3192';
    let selectedShape = null;
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const shapeHistory = [];
    const redoStack = []; // For future redo functionality

    // Add color palette handler
    document.querySelectorAll('.color-swatch').forEach(swatch => {
      swatch.addEventListener(isMobile ? 'touchstart' : 'click', (e) => {
        if (isMobile) e.preventDefault();
        document.querySelectorAll('.color-swatch').forEach(x => x.style.border = '2px solid #ccc');
        swatch.style.border = '2px solid #000';
        selectedColor = swatch.dataset.color;

        if (selectedShape) {
          const shapeEl = selectedShape.querySelector('svg > *');
          if (shapeEl) {
            shapeEl.setAttribute('fill', selectedColor);
            // Update color in history if this shape exists there
            const historyItem = shapeHistory.find(item => item.domRef === selectedShape);
            if (historyItem) historyItem.color = selectedColor;
          }
        }
      });
    });

    // Add shape palette handler
    document.querySelectorAll('.shape-icon').forEach(icon => {
      icon.addEventListener('click', (e) => {
        e.preventDefault();
        const shapeKey = icon.dataset.shape;
        createShape(shapeKey);
      });
    });

    // Undo button handler
    document.getElementById('undo-btn').addEventListener('click', () => {
      if (shapeHistory.length > 0) {
        const lastAction = shapeHistory.pop();
        if (lastAction.domRef && lastAction.domRef.parentNode) {
          lastAction.domRef.remove();
          if (selectedShape === lastAction.domRef) {
            selectedShape = null;
          }
          // Push to redo stack for future implementation
          redoStack.push(lastAction);
        }
      }
    });

    function createShape(shapeKey, savedState = null) {
      const div = document.createElement('div');
      div.className = 'canvas-shape';
      div.innerHTML = shapeSVGs[shapeKey];
      
      // Initialize with saved state or defaults
      div._x = savedState?.x || (canvas.getBoundingClientRect().width / 2 - 40);
      div._y = savedState?.y || (canvas.getBoundingClientRect().height / 2 - 40);
      div._scale = savedState?.scale || 1;
      div._rotation = savedState?.rotation || 0;
      const fillColor = savedState?.color || selectedColor;

      // Set initial properties
      const shapeElement = div.querySelector('svg > *');
      if (shapeElement) shapeElement.setAttribute('fill', fillColor);
      updateTransform(div);
      canvas.appendChild(div);

      // Save to history if this is a new shape (not being recreated)
      if (!savedState) {
        shapeHistory.push({
          type: shapeKey,
          x: div._x,
          y: div._y,
          scale: div._scale,
          rotation: div._rotation,
          color: fillColor,
          domRef: div
        });
      }

      // Bring to front on tap
      div.addEventListener('pointerdown', () => {
        canvas.appendChild(div);
      });

      // Touch events
      let startTouches = [];
      let origState = {};
      let dragging = false;
      let lastTap = 0;
      let gestureInProgress = false;
      let longPressTimer = null;
      let hasMoved = false;

      div.addEventListener('touchstart', e => {
        e.preventDefault();
        hasMoved = false;
        
        // Set up long press timer
        longPressTimer = setTimeout(() => {
          if (!hasMoved) {
            // Shrink and fade animation
            div.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
            div.style.transform = `${div.style.transform} scale(0.1)`;
            div.style.opacity = '0';

            // Remove after animation completes
            setTimeout(() => {
              if (div.parentNode) {
                div.remove();
                // Remove from history if deleting
                const index = shapeHistory.findIndex(item => item.domRef === div);
                if (index > -1) {
                  shapeHistory.splice(index, 1);
                }
                if (selectedShape === div) {
                  selectedShape = null;
                }
              }
            }, 300);
          }
        }, 600);

        if (e.touches.length === 1) {
          dragging = true;
          const touch = e.touches[0];
          origState.x = div._x;
          origState.y = div._y;
          origState.startX = touch.clientX;
          origState.startY = touch.clientY;
        } else if (e.touches.length === 2) {
          dragging = false;
          startTouches = [...e.touches];
          origState.scale = div._scale;
          origState.rotation = div._rotation;
          origState.startDist = getDist(startTouches);
          origState.startAngle = getAngle(startTouches);
        }
        canvas.appendChild(div); // bring to front
      }, { passive: false });

      div.addEventListener('touchmove', e => {
        e.preventDefault();
        hasMoved = true;
        gestureInProgress = true;
        clearTimeout(longPressTimer);
        
        if (e.touches.length === 1 && dragging) {
          const touch = e.touches[0];
          const dx = touch.clientX - origState.startX;
          const dy = touch.clientY - origState.startY;
          div._x = origState.x + dx;
          div._y = origState.y + dy;
          updateTransform(div);
          
          // Update position in history
          const historyItem = shapeHistory.find(item => item.domRef === div);
          if (historyItem) {
            historyItem.x = div._x;
            historyItem.y = div._y;
          }
        } else if (e.touches.length === 2 && startTouches.length === 2) {
          const newDist = getDist(e.touches);
          const newAngle = getAngle(e.touches);
          const scale = origState.scale * (newDist / origState.startDist);
          const rotation = origState.rotation + (newAngle - origState.startAngle);
          div._scale = scale;
          div._rotation = rotation;
          updateTransform(div);
          
          // Update scale/rotation in history
          const historyItem = shapeHistory.find(item => item.domRef === div);
          if (historyItem) {
            historyItem.scale = div._scale;
            historyItem.rotation = div._rotation;
          }
        }
      }, { passive: false });

      div.addEventListener('touchend', e => {
        clearTimeout(longPressTimer);
        
        if (gestureInProgress || hasMoved) {
          gestureInProgress = false;
          hasMoved = false;
          dragging = false;
          startTouches = [];
          return;
        }

        const now = Date.now();
        
        // Double-tap check
        if (now - lastTap < 300 && !dragging && e.touches.length === 0) {
          const clone = createShape(shapeKey, {
            x: div._x + 20,
            y: div._y + 20,
            scale: div._scale,
            rotation: div._rotation,
            color: div.querySelector('svg > *')?.getAttribute('fill') || selectedColor
          });
          return;
        }

        // Select this shape (only if not dragging and no movement)
        if (!dragging && e.touches.length === 0) {
          if (selectedShape) {
            selectedShape.classList.remove('selected');
          }
          selectedShape = div;
          div.classList.add('selected');
        }

        lastTap = now;
        dragging = false;
        startTouches = [];
      });

      // Pointer events for desktop
      div.addEventListener('pointerdown', e => {
        e.preventDefault();
        dragging = true;
        origState.x = div._x;
        origState.y = div._y;
        origState.startX = e.clientX;
        origState.startY = e.clientY;
        canvas.appendChild(div);
      });

      div.addEventListener('pointermove', e => {
        if (!dragging) return;
        e.preventDefault();
        const dx = e.clientX - origState.startX;
        const dy = e.clientY - origState.startY;
        div._x = origState.x + dx;
        div._y = origState.y + dy;
        updateTransform(div);
        
        // Update position in history
        const historyItem = shapeHistory.find(item => item.domRef === div);
        if (historyItem) {
          historyItem.x = div._x;
          historyItem.y = div._y;
        }
      });

      div.addEventListener('pointerup', (e) => {
        if (!dragging) {
          if (selectedShape) {
            selectedShape.classList.remove('selected');
          }
          selectedShape = div;
          div.classList.add('selected');
        }
        dragging = false;
      });

      return div;
    }

    function updateTransform(el) {
      el.style.transform = `translate(${el._x}px, ${el._y}px) scale(${el._scale}) rotate(${el._rotation}deg)`;
    }

    function getDist(touches) {
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.hypot(dx, dy);
    }

    function getAngle(touches) {
      const dx = touches[1].clientX - touches[0].clientX;
      const dy = touches[1].clientY - touches[0].clientY;
      return Math.atan2(dy, dx) * (180 / Math.PI);
    }
  </script>
</body>
</html>