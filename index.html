<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#E594BF">
  <script>
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("service-worker.js").catch(console.error);
    }
  </script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
  <title>DooDo v0.8.2 (All shapes)</title>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    html,body { width:100%;height:100%;overflow:hidden;touch-action:none; }
    body { background:#E594BF;font-family:sans-serif;position:fixed; }

    /* Scrollable palette */
    #palette { 
      display:flex; 
      background:#fff; 
      padding:8px; 
      gap:8px; 
      align-items:center;
      position:relative; 
      z-index:10; 
      overflow-x:auto; 
      -webkit-overflow-scrolling:touch;
    }

    .shape-icon, .color-swatch {
      flex:0 0 auto;
      width:32px; 
      height:32px;
      border:2px solid #ccc; 
      border-radius:4px;
      display:flex; 
      justify-content:center; 
      align-items:center;
      cursor:pointer; 
      user-select:none;
      -webkit-tap-highlight-color:transparent;
    }
    .color-swatch { border-radius:50%; }

    #canvas {
      position:fixed; 
      top:52px; 
      left:0;
      width:100vw; 
      height:calc(100vh - 52px);
      overflow:hidden;
    }
    .canvas-shape {
      position:absolute; 
      touch-action:none;
      user-select:none; 
      -webkit-user-select:none;
      transform-origin:center center;
      will-change:transform; 
      transition:none;
    }
    .canvas-shape.chaos-outline {
      outline:3px dashed #FF0000; 
      outline-offset:-3px;
    }

    /* Toolbar */
    #toolbar {
      position:fixed; 
      top:8px; 
      right:12px;
      display:flex; 
      gap:8px; 
      z-index:100;
    }
    .tool-button {
      width:36px; 
      height:36px; 
      background:white;
      border:2px solid #ccc; 
      border-radius:50%;
      display:flex; 
      justify-content:center; 
      align-items:center;
      font-size:18px; 
      cursor:pointer; 
      user-select:none;
    }

    #chaos-button {
      position:fixed; 
      top:8px; 
      right:160px; 
      z-index:100;
      background:#ED1C24; 
      color:white; 
      border:2px solid black;
      font-family:monospace; 
      font-weight:bold; 
      font-size:14px;
      padding:6px 12px; 
      border-radius:4px;
      box-shadow:2px 2px 0 #000; 
      cursor:pointer;
      transition:all 0.2s;
    }
    @keyframes shake {
      0%,100%{transform:translateX(0)}
      10%,30%,50%,70%,90%{transform:translateX(-3px)}
      20%,40%,60%,80%{transform:translateX(3px)}
    }
  </style>
</head>
<body>
  <div id="palette">
    <!-- Shape icons: scrollable -->
    <div class="shape-icon" data-shape="circle">‚óØ</div>
    <div class="shape-icon" data-shape="rect">‚óªÔ∏é</div>
    <div class="shape-icon" data-shape="triangle">‚ñ≥</div>
    <div class="shape-icon" data-shape="Arch">üèõÔ∏è</div>
    <div class="shape-icon" data-shape="ArrowRight">‚û°Ô∏è</div>
    <div class="shape-icon" data-shape="Comb">üîß</div>
    <div class="shape-icon" data-shape="Doll">ü™Ü</div>
    <div class="shape-icon" data-shape="DoubleStar">‚ú¥Ô∏è</div>
    <div class="shape-icon" data-shape="Flower">üå∏</div>
    <div class="shape-icon" data-shape="Hexagon4">‚¨°</div>
    <div class="shape-icon" data-shape="Octadecagon">üî∑</div>
    <div class="shape-icon" data-shape="Petal">üåø</div>
    <div class="shape-icon" data-shape="Zigzag">‚ö°</div>

    <!-- Color swatches -->
    <div class="color-swatch" data-color="rgba(237,28,36,0.56)" style="background:rgba(237,28,36,0.56);border:2px solid #000;"></div>
    <div class="color-swatch" data-color="#2E3192" style="background:#2E3192;"></div>
    <div class="color-swatch" data-color="#FAF073" style="background:#FAF073;"></div>
  </div>

  <div id="canvas"></div>

  <!-- Toolbar and Chaos toggle -->
  <div id="toolbar">
    <div id="export-png" class="tool-button" title="Export">üñºÔ∏è</div>
    <div id="undo-btn" class="tool-button" title="Undo">‚Ü©Ô∏è</div>
    <div id="redo-btn" class="tool-button" title="Redo">‚Ü™Ô∏è</div>
  </div>
  <button id="chaos-button">DON'T PRESS ME</button>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script>
    const DEFAULT_SHAPE_SIZE = 120;
    const shapeSVGs = {
      circle: `<svg xmlns="http://www.w3.org/2000/svg" width="${DEFAULT_SHAPE_SIZE}" height="${DEFAULT_SHAPE_SIZE}"><circle cx="${DEFAULT_SHAPE_SIZE/2}" cy="${DEFAULT_SHAPE_SIZE/2}" r="${DEFAULT_SHAPE_SIZE/2-2}"/></svg>`,
      rect: `<svg xmlns="http://www.w3.org/2000/svg" width="${DEFAULT_SHAPE_SIZE}" height="${DEFAULT_SHAPE_SIZE}"><rect width="${DEFAULT_SHAPE_SIZE}" height="${DEFAULT_SHAPE_SIZE}"/></svg>`,
      triangle: `<svg xmlns="http://www.w3.org/2000/svg" width="${DEFAULT_SHAPE_SIZE}" height="${DEFAULT_SHAPE_SIZE}"><polygon points="${DEFAULT_SHAPE_SIZE/2},2 ${DEFAULT_SHAPE_SIZE-2},${DEFAULT_SHAPE_SIZE-2} 2,${DEFAULT_SHAPE_SIZE-2}"/></svg>`,
      Arch: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 194.19 97.1" width="${DEFAULT_SHAPE_SIZE}" height="${DEFAULT_SHAPE_SIZE}"><path d="M97.1,0C43.47,0,0,43.47,0,97.1H194.19V0Z" fill="currentColor"/></svg>`,
      ArrowRight: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 12" width="${DEFAULT_SHAPE_SIZE}" height="${DEFAULT_SHAPE_SIZE}"><path d="M1,6h10M6,1l5,5-5,5" stroke="currentColor" stroke-width="2" fill="none"/></svg>`,
      Comb: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" width="${DEFAULT_SHAPE_SIZE}" height="${DEFAULT_SHAPE_SIZE}"><path d="M10,90h80V10M30,90V30M50,90V10M70,90V50" stroke="currentColor" stroke-width="8" fill="none"/></svg>`,
      Doll: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 200" width="${DEFAULT_SHAPE_SIZE}" height="${DEFAULT_SHAPE_SIZE}"><path d="M50,0A50,50,0,1,1,0,50V200h100V50A50,50,0,0,1,50,0Z" fill="currentColor"/></svg>`,
      DoubleStar: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" width="${DEFAULT_SHAPE_SIZE}" height="${DEFAULT_SHAPE_SIZE}"><path d="M16 0l4.9 10 10.9 1.6-7.9 7.7 1.9 10.9L16 23.6 6.2 30.2l1.9-10.9L.2 11.6l10.9-1.6zM16 8l2 4 4.4 .6-3.2 3.1 .8 4.4L16 20l-3.2 1.7 .8-4.4-3.2-3.1 4.4-.6z" fill="currentColor"/></svg>`,
      Flower: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 38.835 42.416" width="${DEFAULT_SHAPE_SIZE}" height="${DEFAULT_SHAPE_SIZE}"><path d="M27.533,8.223a7.723,7.723,0,1,0-15.447,0A7.723,7.723,0,1,0,4.363,21.6a7.723,7.723,0,1,0,7.723,13.377,7.723,7.723,0,1,0,15.447,0A7.723,7.723,0,1,0,35.256,21.6,7.723,7.723,0,0,0,27.533,8.223Z" transform="translate(-0.392 -0.392)" fill="currentColor"/></svg>`,
      Hexagon4: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 86.6" width="${DEFAULT_SHAPE_SIZE}" height="${DEFAULT_SHAPE_SIZE}"><polygon points="50,0 100,25 100,75 50,100 0,75 0,25" fill="currentColor"/></svg>`,
      Octadecagon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 120 120" width="${DEFAULT_SHAPE_SIZE}" height="${DEFAULT_SHAPE_SIZE}"><polygon points="60,0 90,10 110,30 120,60 110,90 90,110 60,120 30,110 10,90 0,60 10,30 30,10" fill="currentColor"/></svg>`,
      Petal: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 200" width="${DEFAULT_SHAPE_SIZE}" height="${DEFAULT_SHAPE_SIZE}"><path d="M50,0C30,50,0,70,0,100s30,50,50,200s50,-50,50,-100s-30,-50,-50,-200Z" fill="currentColor"/></svg>`,
      Zigzag: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 30" width="${DEFAULT_SHAPE_SIZE}" height="${DEFAULT_SHAPE_SIZE}"><polyline points="0,15 25,0 50,15 75,0 100,15" stroke="currentColor" stroke-width="8" fill="none"/></svg>`
    };

    const canvas = document.getElementById('canvas');
    let selectedColor = 'rgba(237,28,36,0.56)';
    let selectedShape = null;
    let chaosMode = false;
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const stateHistory = [];
    let currentStateIndex = -1;

    // Chaos toggle
    document.getElementById('chaos-button').addEventListener('click', () => {
      chaosMode = !chaosMode;
      const btn = document.getElementById('chaos-button');
      btn.textContent = chaosMode ? 'CHAOS MODE ‚ò†Ô∏è' : "DON'T PRESS ME";
      btn.style.background = chaosMode ? '#000' : '#ED1C24';
      btn.style.color = chaosMode ? '#FAF073' : 'white';
      btn.style.boxShadow = chaosMode ? '3px 3px 0 #ED1C24' : '2px 2px 0 #000';
      document.getElementById('toolbar').style.display = chaosMode ? 'none' : 'flex';
      if (selectedShape) {
        selectedShape.classList.toggle('chaos-outline', chaosMode);
        if (!chaosMode) addPreciseSelectionOverlay(selectedShape);
      }
      if (chaosMode) { btn.style.animation='shake 0.5s'; setTimeout(() => btn.style.animation='',500); }
    });

    saveState(true);

    document.querySelectorAll('.color-swatch').forEach(swatch => {
      swatch.addEventListener(isMobile ? 'touchstart' : 'click', (e) => {
        if (isMobile) e.preventDefault();
        document.querySelectorAll('.color-swatch').forEach(x => x.style.border = '2px solid #ccc');
        swatch.style.border = '2px solid #000';
        selectedColor = swatch.dataset.color;

        if (selectedShape) {
          const shapeEl = selectedShape.querySelector('svg > *');
          if (shapeEl) {
            shapeEl.setAttribute('fill', selectedColor);
            if (shapeEl.hasAttribute('stroke')) {
              shapeEl.setAttribute('stroke', selectedColor);
            }
          }
          if (!chaosMode) saveState();
        }
      });
    });

    document.querySelectorAll('.shape-icon').forEach(icon => {
      icon.addEventListener('click', (e) => {
        e.preventDefault();
        const shapeKey = icon.dataset.shape;
        createShape(shapeKey);
        if (!chaosMode) saveState();
      });
    });

    document.getElementById('undo-btn').addEventListener('click', () => {
      if (!chaosMode && stateHistory.length > 1 && currentStateIndex > 0) {
        currentStateIndex--;
        restoreState();
      }
    });

    document.getElementById('redo-btn').addEventListener('click', () => {
      if (!chaosMode && currentStateIndex < stateHistory.length - 1) {
        currentStateIndex++;
        restoreState();
      }
    });

    document.getElementById('export-png').addEventListener('click', () => {
      if (chaosMode) return;
      
      const toolbar = document.getElementById('toolbar');
      const chaosBtn = document.getElementById('chaos-button');
      const originalToolbarDisplay = toolbar.style.display;
      const originalChaosBtnDisplay = chaosBtn.style.display;
      
      toolbar.style.display = 'none';
      chaosBtn.style.display = 'none';
      
      html2canvas(canvas, {
        backgroundColor: '#E594BF',
        scale: 2
      }).then(canvasImg => {
        const link = document.createElement('a');
        link.download = 'DooDo-Artwork-' + new Date().toISOString().slice(0, 10) + '.png';
        link.href = canvasImg.toDataURL('image/png');
        link.click();
        
        toolbar.style.display = originalToolbarDisplay;
        chaosBtn.style.display = originalChaosBtnDisplay;
      });
    });

    function saveState(initial = false) {
      if (chaosMode && !initial) return;
      
      if (!initial && stateHistory.length > 0) {
        const currentState = JSON.stringify(stateHistory[currentStateIndex]);
        const newState = JSON.stringify(getCurrentShapes());
        if (currentState === newState) return;
      }
      
      if (currentStateIndex < stateHistory.length - 1) {
        stateHistory.length = currentStateIndex + 1;
      }
      
      stateHistory.push(getCurrentShapes());
      currentStateIndex = stateHistory.length - 1;
      updateButtonStates();
    }

    function getCurrentShapes() {
      const shapes = [];
      document.querySelectorAll('.canvas-shape').forEach(shape => {
        shapes.push({
          type: shape.innerHTML.includes('circle') ? 'circle' : 
                shape.innerHTML.includes('rect') ? 'rect' : 
                shape.innerHTML.includes('polygon') ? 'triangle' :
                shape.innerHTML.includes('path') ? 
                  (shape.innerHTML.includes('M50,0A50,50') ? 'Doll' :
                  (shape.innerHTML.includes('M10,90h80V10') ? 'Comb' :
                  (shape.innerHTML.includes('M1,6h10') ? 'ArrowRight' :
                  (shape.innerHTML.includes('M97.1,0C43.47') ? 'Arch' :
                  (shape.innerHTML.includes('M16 0l4.9 10') ? 'DoubleStar' :
                  (shape.innerHTML.includes('M27.533,8.223') ? 'Flower' :
                  (shape.innerHTML.includes('M50,0C30,50') ? 'Petal' :
                  (shape.innerHTML.includes('points="0,15 25,0') ? 'Zigzag' :
                  (shape.innerHTML.includes('points="50,0 100,25') ? 'Hexagon4' : 'Octadecagon')))))))),
          x: shape._x,
          y: shape._y,
          scale: shape._scale,
          rotation: shape._rotation,
          color: shape.querySelector('svg > *')?.getAttribute('fill') || selectedColor
        });
      });
      return shapes;
    }

    function restoreState() {
      while (canvas.firstChild) {
        canvas.removeChild(canvas.firstChild);
      }
      selectedShape = null;
      
      const shapes = stateHistory[currentStateIndex];
      shapes.forEach(shapeData => {
        createShape(shapeData.type, shapeData);
      });
      updateButtonStates();
    }

    function updateButtonStates() {
      if (chaosMode) return;
      document.getElementById('undo-btn').style.opacity = stateHistory.length <= 1 || currentStateIndex <= 0 ? '0.5' : '1';
      document.getElementById('redo-btn').style.opacity = currentStateIndex >= stateHistory.length - 1 ? '0.5' : '1';
    }

    function addPreciseSelectionOverlay(div) {
      const shape = div.querySelector('svg > *');
      if (shape) {
        shape.setAttribute('stroke', '#000');
        shape.setAttribute('stroke-width', '2');
        shape.setAttribute('stroke-dasharray', '4 2');
        shape.setAttribute('stroke-linejoin', 'round');
        shape.setAttribute('vector-effect', 'non-scaling-stroke');
      }
      div.classList.remove('chaos-outline');
    }

    function addChaosSelectionOverlay(div) {
      div.classList.add('chaos-outline');
      const shape = div.querySelector('svg > *');
      if (shape) {
        shape.removeAttribute('stroke');
        shape.removeAttribute('stroke-width');
        shape.removeAttribute('stroke-dasharray');
      }
    }

    function removeSelectionOverlay(div) {
      if (!div) return;
      div.classList.remove('chaos-outline');
      const shape = div.querySelector('svg > *');
      if (shape) {
        shape.removeAttribute('stroke');
        shape.removeAttribute('stroke-width');
        shape.removeAttribute('stroke-dasharray');
        shape.removeAttribute('vector-effect');
      }
    }

    function createShape(shapeKey, shapeData = null) {
      const div = document.createElement('div');
      div.className = 'canvas-shape';
      div.innerHTML = shapeSVGs[shapeKey];
      
      // Randomize starting position if not specified
      const canvasRect = canvas.getBoundingClientRect();
      div._x = shapeData?.x || (Math.random() * (canvasRect.width - DEFAULT_SHAPE_SIZE * 0.8));
      div._y = shapeData?.y || (Math.random() * (canvasRect.height - DEFAULT_SHAPE_SIZE * 0.8));
      
      div._scale = shapeData?.scale || 1;
      div._rotation = shapeData?.rotation || 0;
      const fillColor = shapeData?.color || selectedColor;

      const shapeElement = div.querySelector('svg > *');
      if (shapeElement) {
        shapeElement.setAttribute('fill', fillColor);
        if (shapeElement.hasAttribute('stroke')) {
          shapeElement.setAttribute('stroke', fillColor);
        }
      }
      
      if (selectedShape) {
        removeSelectionOverlay(selectedShape);
      }
      
      if (chaosMode) {
        addChaosSelectionOverlay(div);
      } else {
        addPreciseSelectionOverlay(div);
      }
      
      selectedShape = div;
      updateTransform(div);
      canvas.appendChild(div);

      setupShapeInteractions(div, shapeKey);
      return div;
    }

    function setupShapeInteractions(div, shapeKey) {
      const bringToFront = () => {
        canvas.appendChild(div);
        if (selectedShape && selectedShape !== div) {
          removeSelectionOverlay(selectedShape);
        }
        selectedShape = div;
        if (chaosMode) {
          addChaosSelectionOverlay(div);
        } else {
          addPreciseSelectionOverlay(div);
        }
      };

      let startTouches = [];
      let origState = {};
      let dragging = false;
      let lastTap = 0;
      let gestureInProgress = false;
      let longPressTimer = null;
      let hasMoved = false;

      div.addEventListener('touchstart', e => {
        bringToFront();
        e.preventDefault();
        hasMoved = false;
        
        longPressTimer = setTimeout(() => {
          if (!hasMoved) {
            animateDelete(div);
          }
        }, 600);

        if (e.touches.length === 1) {
          dragging = true;
          const touch = e.touches[0];
          origState.x = div._x;
          origState.y = div._y;
          origState.startX = touch.clientX;
          origState.startY = touch.clientY;
        } else if (e.touches.length === 2) {
          dragging = false;
          startTouches = [...e.touches];
          origState.scale = div._scale;
          origState.rotation = div._rotation;
          origState.startDist = getDist(startTouches);
          origState.startAngle = getAngle(startTouches);
        }
      }, { passive: false });

      div.addEventListener('touchmove', e => {
        e.preventDefault();
        hasMoved = true;
        gestureInProgress = true;
        clearTimeout(longPressTimer);
        
        if (e.touches.length === 1 && dragging) {
          const touch = e.touches[0];
          const dx = touch.clientX - origState.startX;
          const dy = touch.clientY - origState.startY;
          div._x = origState.x + dx;
          div._y = origState.y + dy;
          updateTransform(div);
        } else if (e.touches.length === 2 && startTouches.length === 2) {
          const newDist = getDist(e.touches);
          const newAngle = getAngle(e.touches);
          const scale = origState.scale * (newDist / origState.startDist);
          const rotation = origState.rotation + (newAngle - origState.startAngle);
          div._scale = scale;
          div._rotation = rotation;
          updateTransform(div);
        }
      }, { passive: false });

      div.addEventListener('touchend', e => {
        clearTimeout(longPressTimer);
        
        if (gestureInProgress || hasMoved) {
          gestureInProgress = false;
          hasMoved = false;
          dragging = false;
          startTouches = [];
          if (!chaosMode) saveState();
          return;
        }

        const now = Date.now();
        
        if (now - lastTap < 300 && !dragging && e.touches.length === 0) {
          if (chaosMode) {
            // Chaos mode: random direction and distance
            const angle = Math.random() * Math.PI * 2;
            const dist = 30 + Math.random() * 20;
            const dx = Math.cos(angle) * dist;
            const dy = Math.sin(angle) * dist;
            
            const clone = createShape(shapeKey, {
              x: div._x + dx,
              y: div._y + dy,
              scale: div._scale,
              rotation: div._rotation,
              color: div.querySelector('svg > *')?.getAttribute('fill') || selectedColor
            });
          } else {
            // Normal mode: fixed offset
            const clone = createShape(shapeKey, {
              x: div._x + 20,
              y: div._y + 20,
              scale: div._scale,
              rotation: div._rotation,
              color: div.querySelector('svg > *')?.getAttribute('fill') || selectedColor
            });
          }
          if (!chaosMode) saveState();
          return;
        }

        if (!dragging && e.touches.length === 0) {
          handleSelectionLogic(div);
        }

        lastTap = now;
        dragging = false;
        startTouches = [];
      });

      div.addEventListener('pointerdown', (e) => {
        bringToFront();
        e.preventDefault();
        dragging = true;
        origState.x = div._x;
        origState.y = div._y;
        origState.startX = e.clientX;
        origState.startY = e.clientY;
      });

      div.addEventListener('pointermove', e => {
        if (!dragging) return;
        e.preventDefault();
        const dx = e.clientX - origState.startX;
        const dy = e.clientY - origState.startY;
        div._x = origState.x + dx;
        div._y = origState.y + dy;
        updateTransform(div);
      });

      div.addEventListener('pointerup', (e) => {
        if (!dragging) {
          handleSelectionLogic(div);
        } else if (!chaosMode) {
          saveState();
        }
        dragging = false;
      });
    }

    function handleSelectionLogic(clickedShape) {
      if (chaosMode) {
        const allShapes = Array.from(document.querySelectorAll('.canvas-shape'));
        
        // 40% chance we select a totally random shape
        if (Math.random() < 0.4 && allShapes.length > 1) {
          const candidates = allShapes.filter(s => s !== clickedShape);
          const randomShape = candidates[Math.floor(Math.random() * candidates.length)];

          if (selectedShape && selectedShape !== randomShape) {
            removeSelectionOverlay(selectedShape);
          }

          addChaosSelectionOverlay(randomShape);
          selectedShape = randomShape;
        } else {
          // 30% chance we select *nothing*
          if (Math.random() < 0.3) {
            if (selectedShape) removeSelectionOverlay(selectedShape);
            selectedShape = null;
          } else {
            // Normal selection (30% chance)
            if (selectedShape && selectedShape !== clickedShape) {
              removeSelectionOverlay(selectedShape);
            }
            addChaosSelectionOverlay(clickedShape);
            selectedShape = clickedShape;
          }
        }
      } else {
        // Normal mode - just select the clicked shape
        if (selectedShape && selectedShape !== clickedShape) {
          removeSelectionOverlay(selectedShape);
        }
        addPreciseSelectionOverlay(clickedShape);
        selectedShape = clickedShape;
      }
    }

    function animateDelete(shape) {
      shape.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
      shape.style.transform = `${shape.style.transform} scale(0.1)`;
      shape.style.opacity = '0';

      setTimeout(() => {
        if (shape.parentNode) {
          shape.remove();
          if (selectedShape === shape) {
            selectedShape = null;
          }
          if (!chaosMode) saveState();
        }
      }, 300);
    }

    function updateTransform(el) {
      el.style.transform = `translate(${el._x}px, ${el._y}px) scale(${el._scale}) rotate(${el._rotation}deg)`;
    }

    function getDist(touches) {
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.hypot(dx, dy);
    }

    function getAngle(touches) {
      const dx = touches[1].clientX - touches[0].clientX;
      const dy = touches[1].clientY - touches[0].clientY;
      return Math.atan2(dy, dx) * (180 / Math.PI);
    }

    updateButtonStates();
  </script>
</body>
</html>