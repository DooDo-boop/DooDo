<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>DooDo v0.3.1 (Shape Coloring)</title>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    html, body { 
      width:100%; height:100%; 
      overflow:hidden;
      touch-action:none;
    }
    body { 
      background: #E594BF;
      font-family: sans-serif;
      position:fixed;
    }
    #palette {
      display:flex; background:#fff; padding:8px;
      gap:12px; align-items:center;
      position:relative;
      z-index:10;
    }
    .shape-icon, .color-swatch {
      width:32px; height:32px;
      border:2px solid #ccc; border-radius:4px;
      display:flex; justify-content:center; align-items:center;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color:transparent;
    }
    .color-swatch { border-radius:50%; }
    #canvas {
      position:fixed;
      width:100vw; 
      height:calc(100vh - 52px);
      top:52px;
      left:0;
      overflow:hidden;
    }
    .canvas-shape {
      position:absolute; 
      touch-action:none;
      user-select:none;
      -webkit-user-select:none;
      transform-origin: center center;
      will-change: transform;
    }
    .canvas-shape.selected {
      outline: 2px dashed black;
    }
  </style>
</head>
<body>
  <div id="palette">
    <div id="shape-palette">
      <div class="shape-icon" data-shape="circle">◯</div>
      <div class="shape-icon" data-shape="rect">◻︎</div>
      <div class="shape-icon" data-shape="triangle">△</div>
    </div>
    <div id="color-palette">
      <div class="color-swatch" data-color="#2E3192" style="background:#2E3192;"></div>
      <div class="color-swatch" data-color="rgba(237,28,36,0.56)" style="background:rgba(237,28,36,0.56);"></div>
      <div class="color-swatch" data-color="#FAF073" style="background:#FAF073;"></div>
    </div>
  </div>
  <div id="canvas"></div>

  <script>
    const shapeSVGs = {
      circle: '<svg xmlns="http://www.w3.org/2000/svg" width="80" height="80"><circle cx="40" cy="40" r="40"/></svg>',
      rect: '<svg xmlns="http://www.w3.org/2000/svg" width="80" height="80"><rect width="80" height="80"/></svg>',
      triangle: '<svg xmlns="http://www.w3.org/2000/svg" width="80" height="80"><polygon points="40,0 80,80 0,80"/></svg>'
    };

    const canvas = document.getElementById('canvas');
    let selectedColor = '#2E3192';
    let selectedShape = null;
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

    // Add color palette handler
    document.querySelectorAll('.color-swatch').forEach(swatch => {
      swatch.addEventListener(isMobile ? 'touchstart' : 'click', (e) => {
        if (isMobile) e.preventDefault();
        document.querySelectorAll('.color-swatch').forEach(x => x.style.border = '2px solid #ccc');
        swatch.style.border = '2px solid #000';
        selectedColor = swatch.dataset.color;

        if (selectedShape) {
          const shapeEl = selectedShape.querySelector('svg > *');
          if (shapeEl) shapeEl.setAttribute('fill', selectedColor);
        }
      });
    });

    // Add shape palette handler
    document.querySelectorAll('.shape-icon').forEach(icon => {
      icon.addEventListener('click', (e) => {
        e.preventDefault();
        const shapeKey = icon.dataset.shape;
        createShape(shapeKey);
      });
    });

    function createShape(shapeKey) {
      const div = document.createElement('div');
      div.className = 'canvas-shape';
      div.innerHTML = shapeSVGs[shapeKey];
      div.style.position = 'absolute';
      
      // Center the shape initially
      const rect = canvas.getBoundingClientRect();
      div._x = rect.width / 2 - 40;
      div._y = rect.height / 2 - 40;
      div._scale = 1;
      div._rotation = 0;
      
      // Set initial color
      const shapeElement = div.querySelector('svg > *');
      if (shapeElement) shapeElement.setAttribute('fill', selectedColor);

      updateTransform(div);
      canvas.appendChild(div);

      // Bring to front on tap
      div.addEventListener('pointerdown', () => {
        canvas.appendChild(div);
      });

      // Touch events
      let startTouches = [];
      let origState = {};
      let dragging = false;
      let lastTap = 0;

      div.addEventListener('touchstart', e => {
        e.preventDefault();
        if (e.touches.length === 1) {
          dragging = true;
          const touch = e.touches[0];
          origState.x = div._x;
          origState.y = div._y;
          origState.startX = touch.clientX;
          origState.startY = touch.clientY;
        } else if (e.touches.length === 2) {
          dragging = false;
          startTouches = [...e.touches];
          origState.scale = div._scale;
          origState.rotation = div._rotation;
          origState.startDist = getDist(startTouches);
          origState.startAngle = getAngle(startTouches);
        }
        canvas.appendChild(div); // bring to front
      }, { passive: false });

      div.addEventListener('touchmove', e => {
        e.preventDefault();
        if (e.touches.length === 1 && dragging) {
          const touch = e.touches[0];
          const dx = touch.clientX - origState.startX;
          const dy = touch.clientY - origState.startY;
          div._x = origState.x + dx;
          div._y = origState.y + dy;
          updateTransform(div);
        } else if (e.touches.length === 2 && startTouches.length === 2) {
          const newDist = getDist(e.touches);
          const newAngle = getAngle(e.touches);
          const scale = origState.scale * (newDist / origState.startDist);
          const rotation = origState.rotation + (newAngle - origState.startAngle);
          div._scale = scale;
          div._rotation = rotation;
          updateTransform(div);
        }
      }, { passive: false });

      div.addEventListener('touchend', e => {
        const now = Date.now();
        
        // Double-tap check (duplicate logic)
        if (now - lastTap < 300 && !dragging && e.touches.length === 0) {
          const clone = createShape(shapeKey);
          clone._x = div._x + 20;
          clone._y = div._y + 20;
          clone._scale = div._scale;
          clone._rotation = div._rotation;
          updateTransform(clone);
          
          // Copy color to clone
          const originalShape = div.querySelector('svg > *');
          const clonedShape = clone.querySelector('svg > *');
          if (originalShape && clonedShape) {
            clonedShape.setAttribute('fill', originalShape.getAttribute('fill'));
          }
          
          return;
        }

        // Select this shape (only if not dragging)
        if (!dragging && e.touches.length === 0) {
          if (selectedShape) {
            selectedShape.classList.remove('selected');
          }
          selectedShape = div;
          div.classList.add('selected');
        }

        lastTap = now;
        dragging = false;
        startTouches = [];
      });

      // Pointer events for desktop
      div.addEventListener('pointerdown', e => {
        e.preventDefault();
        dragging = true;
        origState.x = div._x;
        origState.y = div._y;
        origState.startX = e.clientX;
        origState.startY = e.clientY;
        canvas.appendChild(div);
      });

      div.addEventListener('pointermove', e => {
        if (!dragging) return;
        e.preventDefault();
        const dx = e.clientX - origState.startX;
        const dy = e.clientY - origState.startY;
        div._x = origState.x + dx;
        div._y = origState.y + dy;
        updateTransform(div);
      });

      div.addEventListener('pointerup', (e) => {
        if (!dragging) {
          if (selectedShape) {
            selectedShape.classList.remove('selected');
          }
          selectedShape = div;
          div.classList.add('selected');
        }
        dragging = false;
      });

      return div;
    }

    function updateTransform(el) {
      el.style.transform = `translate(${el._x}px, ${el._y}px) scale(${el._scale}) rotate(${el._rotation}deg)`;
    }

    function getDist(touches) {
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.hypot(dx, dy);
    }

    function getAngle(touches) {
      const dx = touches[1].clientX - touches[0].clientX;
      const dy = touches[1].clientY - touches[0].clientY;
      return Math.atan2(dy, dx) * (180 / Math.PI);
    }
  </script>
</body>
</html>