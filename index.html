<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>DooDo v0.4.3 (More Polish)</title>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    html, body { 
      width:100%; height:100%; 
      overflow:hidden;
      touch-action:none;
    }
    body { 
      background: #E594BF;
      font-family: sans-serif;
      position:fixed;
    }
    #palette {
      display:flex; background:#fff; padding:8px;
      gap:12px; align-items:center;
      position:relative;
      z-index:10;
    }
    .shape-icon, .color-swatch {
      width:32px; height:32px;
      border:2px solid #ccc; border-radius:4px;
      display:flex; justify-content:center; align-items:center;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color:transparent;
    }
    .color-swatch { border-radius:50%; }
    #canvas {
      position:fixed;
      width:100vw; 
      height:calc(100vh - 52px);
      top:52px;
      left:0;
      overflow:hidden;
    }
    .canvas-shape {
      position:absolute; 
      touch-action:none;
      user-select:none;
      -webkit-user-select:none;
      transform-origin: center center;
      will-change: transform;
      transition: none;
    }
    #undo-btn, #redo-btn, #export-png {
      position: fixed;
      bottom: 12px;
      z-index: 99;
      padding: 8px 12px;
      background: white;
      border: 2px solid #ccc;
      border-radius: 4px;
      font-family: sans-serif;
      cursor: pointer;
    }
    #undo-btn {
      right: 100px;
    }
    #redo-btn {
      right: 12px;
    }
    #export-png {
      left: 12px;
    }
    #undo-btn:active, #redo-btn:active, #export-png:active {
      background: #f0f0f0;
    }
  </style>
</head>
<body>
  <div id="palette">
    <div id="shape-palette">
      <div class="shape-icon" data-shape="circle">◯</div>
      <div class="shape-icon" data-shape="rect">◻︎</div>
      <div class="shape-icon" data-shape="triangle">△</div>
    </div>
    <div id="color-palette">
      <div class="color-swatch" data-color="#2E3192" style="background:#2E3192;"></div>
      <div class="color-swatch" data-color="rgba(237,28,36,0.56)" style="background:rgba(237,28,36,0.56);"></div>
      <div class="color-swatch" data-color="#FAF073" style="background:#FAF073;"></div>
    </div>
  </div>
  <div id="canvas"></div>
  <button id="export-png">Export PNG</button>
  <button id="undo-btn">Undo</button>
  <button id="redo-btn">Redo</button>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  
  <script>
    const shapeSVGs = {
      circle: '<svg xmlns="http://www.w3.org/2000/svg" width="80" height="80"><circle cx="40" cy="40" r="40"/></svg>',
      rect: '<svg xmlns="http://www.w3.org/2000/svg" width="80" height="80"><rect width="80" height="80"/></svg>',
      triangle: '<svg xmlns="http://www.w3.org/2000/svg" width="80" height="80"><polygon points="40,0 80,80 0,80"/></svg>'
    };

    const canvas = document.getElementById('canvas');
    let selectedColor = '#2E3192';
    let selectedShape = null;
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    const stateHistory = [];
    let currentStateIndex = -1;
    
    saveState(true);

    document.querySelectorAll('.color-swatch').forEach(swatch => {
      swatch.addEventListener(isMobile ? 'touchstart' : 'click', (e) => {
        if (isMobile) e.preventDefault();
        document.querySelectorAll('.color-swatch').forEach(x => x.style.border = '2px solid #ccc');
        swatch.style.border = '2px solid #000';
        selectedColor = swatch.dataset.color;

        if (selectedShape) {
          const shapeEl = selectedShape.querySelector('svg > *');
          if (shapeEl) shapeEl.setAttribute('fill', selectedColor);
          saveState();
        }
      });
    });

    document.querySelectorAll('.shape-icon').forEach(icon => {
      icon.addEventListener('click', (e) => {
        e.preventDefault();
        const shapeKey = icon.dataset.shape;
        createShape(shapeKey);
        saveState();
      });
    });

    document.getElementById('undo-btn').addEventListener('click', () => {
      if (stateHistory.length > 1 && currentStateIndex > 0) {
        currentStateIndex--;
        restoreState();
      }
    });

    document.getElementById('redo-btn').addEventListener('click', () => {
      if (currentStateIndex < stateHistory.length - 1) {
        currentStateIndex++;
        restoreState();
      }
    });

    document.getElementById('export-png').addEventListener('click', () => {
      const exportBtn = document.getElementById('export-png');
      const undoBtn = document.getElementById('undo-btn');
      const redoBtn = document.getElementById('redo-btn');
      const originalDisplay = [exportBtn.style.display, undoBtn.style.display, redoBtn.style.display];
      
      exportBtn.style.display = 'none';
      undoBtn.style.display = 'none';
      redoBtn.style.display = 'none';
      
      html2canvas(canvas, {
        backgroundColor: '#E594BF',
        scale: 2
      }).then(canvasImg => {
        const link = document.createElement('a');
        link.download = 'DooDo-Artwork-' + new Date().toISOString().slice(0, 10) + '.png';
        link.href = canvasImg.toDataURL('image/png');
        link.click();
        
        exportBtn.style.display = originalDisplay[0];
        undoBtn.style.display = originalDisplay[1];
        redoBtn.style.display = originalDisplay[2];
      });
    });

    function saveState(initial = false) {
      if (!initial && stateHistory.length > 0) {
        const currentState = JSON.stringify(stateHistory[currentStateIndex]);
        const newState = JSON.stringify(getCurrentShapes());
        if (currentState === newState) return;
      }
      
      if (currentStateIndex < stateHistory.length - 1) {
        stateHistory.length = currentStateIndex + 1;
      }
      
      stateHistory.push(getCurrentShapes());
      currentStateIndex = stateHistory.length - 1;
      updateButtonStates();
    }

    function getCurrentShapes() {
      const shapes = [];
      document.querySelectorAll('.canvas-shape').forEach(shape => {
        shapes.push({
          type: shape.innerHTML.includes('circle') ? 'circle' : 
                shape.innerHTML.includes('rect') ? 'rect' : 'triangle',
          x: shape._x,
          y: shape._y,
          scale: shape._scale,
          rotation: shape._rotation,
          color: shape.querySelector('svg > *')?.getAttribute('fill') || selectedColor
        });
      });
      return shapes;
    }

    function restoreState() {
      while (canvas.firstChild) {
        canvas.removeChild(canvas.firstChild);
      }
      selectedShape = null;
      
      const shapes = stateHistory[currentStateIndex];
      shapes.forEach(shapeData => {
        createShape(shapeData.type, shapeData);
      });
      updateButtonStates();
    }

    function updateButtonStates() {
      document.getElementById('undo-btn').disabled = stateHistory.length <= 1 || currentStateIndex <= 0;
      document.getElementById('redo-btn').disabled = currentStateIndex >= stateHistory.length - 1;
    }

    function addSelectionOverlay(div) {
      const shape = div.querySelector('svg > *');
      shape.setAttribute('stroke', '#000');
      shape.setAttribute('stroke-width', '2');
      shape.setAttribute('stroke-dasharray', '4 2');
      shape.setAttribute('stroke-linejoin', 'round');
      shape.setAttribute('vector-effect', 'non-scaling-stroke');
    }

    function removeSelectionOverlay(div) {
      if (!div) return;
      const shape = div.querySelector('svg > *');
      if (shape) {
        shape.removeAttribute('stroke');
        shape.removeAttribute('stroke-width');
        shape.removeAttribute('stroke-dasharray');
        shape.removeAttribute('vector-effect');
      }
    }

    function createShape(shapeKey, shapeData = null) {
      const div = document.createElement('div');
      div.className = 'canvas-shape';
      div.innerHTML = shapeSVGs[shapeKey];
      
      div._x = shapeData?.x || (canvas.getBoundingClientRect().width / 2 - 40);
      div._y = shapeData?.y || (canvas.getBoundingClientRect().height / 2 - 40);
      div._scale = shapeData?.scale || 1;
      div._rotation = shapeData?.rotation || 0;
      const fillColor = shapeData?.color || selectedColor;

      const shapeElement = div.querySelector('svg > *');
      if (shapeElement) shapeElement.setAttribute('fill', fillColor);
      
      // Auto-select the new shape
      if (selectedShape) {
        removeSelectionOverlay(selectedShape);
      }
      addSelectionOverlay(div);
      selectedShape = div;
      
      updateTransform(div);
      canvas.appendChild(div);

      setupShapeInteractions(div, shapeKey);
      return div;
    }

    function setupShapeInteractions(div, shapeKey) {
      div.addEventListener('pointerdown', () => {
        canvas.appendChild(div);
      });

      let startTouches = [];
      let origState = {};
      let dragging = false;
      let lastTap = 0;
      let gestureInProgress = false;
      let longPressTimer = null;
      let hasMoved = false;

      div.addEventListener('touchstart', e => {
        e.preventDefault();
        hasMoved = false;
        
        longPressTimer = setTimeout(() => {
          if (!hasMoved) {
            animateDelete(div);
          }
        }, 600);

        if (e.touches.length === 1) {
          dragging = true;
          const touch = e.touches[0];
          origState.x = div._x;
          origState.y = div._y;
          origState.startX = touch.clientX;
          origState.startY = touch.clientY;
        } else if (e.touches.length === 2) {
          dragging = false;
          startTouches = [...e.touches];
          origState.scale = div._scale;
          origState.rotation = div._rotation;
          origState.startDist = getDist(startTouches);
          origState.startAngle = getAngle(startTouches);
        }
        canvas.appendChild(div);
      }, { passive: false });

      div.addEventListener('touchmove', e => {
        e.preventDefault();
        hasMoved = true;
        gestureInProgress = true;
        clearTimeout(longPressTimer);
        
        if (e.touches.length === 1 && dragging) {
          const touch = e.touches[0];
          const dx = touch.clientX - origState.startX;
          const dy = touch.clientY - origState.startY;
          div._x = origState.x + dx;
          div._y = origState.y + dy;
          updateTransform(div);
        } else if (e.touches.length === 2 && startTouches.length === 2) {
          const newDist = getDist(e.touches);
          const newAngle = getAngle(e.touches);
          const scale = origState.scale * (newDist / origState.startDist);
          const rotation = origState.rotation + (newAngle - origState.startAngle);
          div._scale = scale;
          div._rotation = rotation;
          updateTransform(div);
        }
      }, { passive: false });

      div.addEventListener('touchend', e => {
        clearTimeout(longPressTimer);
        
        if (gestureInProgress || hasMoved) {
          gestureInProgress = false;
          hasMoved = false;
          dragging = false;
          startTouches = [];
          saveState();
          return;
        }

        const now = Date.now();
        
        if (now - lastTap < 300 && !dragging && e.touches.length === 0) {
          const clone = createShape(shapeKey, {
            x: div._x + 20,
            y: div._y + 20,
            scale: div._scale,
            rotation: div._rotation,
            color: div.querySelector('svg > *')?.getAttribute('fill') || selectedColor
          });
          saveState();
          return;
        }

        if (!dragging && e.touches.length === 0) {
          if (selectedShape && selectedShape !== div) {
            removeSelectionOverlay(selectedShape);
          }
          addSelectionOverlay(div);
          selectedShape = div;
        }

        lastTap = now;
        dragging = false;
        startTouches = [];
      });

      div.addEventListener('pointerdown', e => {
        e.preventDefault();
        dragging = true;
        origState.x = div._x;
        origState.y = div._y;
        origState.startX = e.clientX;
        origState.startY = e.clientY;
        canvas.appendChild(div);
      });

      div.addEventListener('pointermove', e => {
        if (!dragging) return;
        e.preventDefault();
        const dx = e.clientX - origState.startX;
        const dy = e.clientY - origState.startY;
        div._x = origState.x + dx;
        div._y = origState.y + dy;
        updateTransform(div);
      });

      div.addEventListener('pointerup', (e) => {
        if (!dragging) {
          if (selectedShape && selectedShape !== div) {
            removeSelectionOverlay(selectedShape);
          }
          addSelectionOverlay(div);
          selectedShape = div;
        } else {
          saveState();
        }
        dragging = false;
      });
    }

    function animateDelete(shape) {
      shape.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
      shape.style.transform = `${shape.style.transform} scale(0.1)`;
      shape.style.opacity = '0';

      setTimeout(() => {
        if (shape.parentNode) {
          shape.remove();
          if (selectedShape === shape) {
            selectedShape = null;
          }
          saveState();
        }
      }, 300);
    }

    function updateTransform(el) {
      el.style.transform = `translate(${el._x}px, ${el._y}px) scale(${el._scale}) rotate(${el._rotation}deg)`;
    }

    function getDist(touches) {
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.hypot(dx, dy);
    }

    function getAngle(touches) {
      const dx = touches[1].clientX - touches[0].clientX;
      const dy = touches[1].clientY - touches[0].clientY;
      return Math.atan2(dy, dx) * (180 / Math.PI);
    }

    updateButtonStates();
  </script>
</body>
</html>